# -*- coding: utf-8 -*-
"""PP_AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JRT82SifSgLKD7dAePjXG9z9gHX_OcKW

# Meal Planner and Groccery Shopping AI

## The Problem
Given that an Agent have a set amount of left over ingredients and in-need of a meal plan which will optimize their **preference** for a given amount of **meals**, the algorithm should be able to generate a list of recipe for the Agent to cook along with the needed ingredient. There should be no left-over ingredients when all of the required meal is generated.

## Environmental Constraint
- There should be no left over ingredient when the algorithm finish
- No Repetitive Meal
- Agent are force to buy ingredient in a pre-defined batch

## Goal State
`{NumberOfMeal: N, Basket: []}`

## Cost Function
`g(n) = w1*totalCost(recipe) + w2*totalCalories(recipe)`

where w1 and w2 and preference weight respectively

## Defining Data

## Domain Related Data
These are the data which are important in terms of solving the problems at hand
###Recipe
- Id: Number
- Name: String
- Ingredients: []Number
- Cuisine: Enum<Cuisine>

###Ingredient
- Id: Number
- Name: String
- Calories: Number
- Cost: Number

### Purchaseable Ingredient
- Ingredient: Number
- BatchPerPurchase: Number

## AI
These are the data which are important for the agent to function

###Node
- Cost: Number
- Basket: []Map<Number>Number (When finish cooking the recipe, what ingredients  would be left)
- MealNumber: Number
- cookeMeal: Number

###Agent
- CaloriesPreference: Float
- CostPreference: Float
- NumberOfMeal: Number
- CookedMeal: []Number
"""

'''
Example Data For Ingredient
{
  id: 1
  name: "Fish"
  calories: 1000
  cost: 300
}
'''

'''
Example Data For Recipe
{
  id: 1
  name: "Fish Curry"
  ingredient: [1,2]
}
'''

'''
Example Node
{
  cost: 3000
  basket: {1:4, 3:2, 1:3}
  mealNumber: 3
  cookedMeal: [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
}
'''

'''
Example AgentState
{
  caloriesPreference: 0.3
  costPreference: 0.7
  numberOfMeal: 21
  fringe: []Number
}
'''

import io
import json
from google.colab import files
import numpy as np

"""#Loading Recipe and Ingredients Data"""

uploaded = files.upload()

global rawRecipes
global rawIngredients
rawRecipes = json.loads(uploaded["recipe.json"].decode('utf-8'))
rawIngredients = json.loads(uploaded["ingredients.json"].decode('utf-8'))

global clonedRecipes
global clonedIngredients
clonedRecipes = rawRecipes.copy()
clonedIngredients = rawIngredients.copy()

"""# Data Exploration"""

print(clonedRecipes[0])

print(clonedIngredients[0])

print("Total Number of Recipe: %d" % (len(clonedRecipes)))
print("Total Number of Ingredients: %d" % (len(clonedIngredients)))

"""# Format Data

## Sample
This function can shuffle the data and take an N amount of entry from a list
"""

def Sample(shuffle, number, objectList):
  clonedObjectList = objectList.copy()
  if len(objectList) < number:
    return clonedObjectList
  if shuffle:
      np.random.shuffle(clonedObjectList)
  return clonedObjectList[0:number]

"""# Normalized_Key
This function normalized the key value to be between 1 - maxRange
"""

def Find_Min_Max(objectList, key):
  min = None
  max = None
  for entry in objectList:
    currentValue = entry[key]
    if min == None or currentValue < min:
      min = currentValue
    if max == None or currentValue > max:
      max = currentValue
  return min, max
    
    
def Normalized_Key(objectList, key, maxValue):
    clonedObjectList = objectList.copy()
    min, max = Find_Min_Max(clonedObjectList, key)
    for entry in clonedObjectList:
      entry[key] = 1+((entry[key] - min)*(maxValue-1))/(max-min)
    return clonedObjectList

"""## Generate_Purchaseable_List
This function generate the amount of ingredient the Agent force to buy when he performs groccery shopping. It can take a number or a random from a uniform distribution.

"""

def Generate_Purchaseable_List(objectList, number, max):
  purchaseableList = {}
  for entry in objectList:
    if number is None:
      purchaseableList[entry] =  int(np.random.uniform(1,max))
    else:
      purchaseableList[entry] = number
  return purchaseableList

"""## Generate_Id
This function generate an id based on a running number for a list
"""

def Generate_Id(objectList):
    clonedObjectList = objectList.copy()
    for index, entry in enumerate(objectList):
      entry["id"] = index
    return clonedObjectList

"""## Format_Ingredient_List_To_Dictionary
This function convert an orginally list of ingredient into a dictionary
"""

def Format_Ingrediet_List_To_Dictionary(ingredientList):
  ingredientDictionary = {}
  for ingredient in ingredientList:
    ingredientDictionary[ingredient["id"]] = {"name": ingredient["name"], "calories": ingredient["cal"], "cost": ingredient["cost"]}
  return ingredientDictionary

"""## Generate_Formatted_Recipes
This function generate a dictionary of recipe and subsistute the ingredients with ingredient id
"""

def Find_Ingredient_Id(ingredientName, ingredientDictionary):
  for id in ingredientDictionary:
    if ingredientDictionary[id]["name"] == ingredientName:
      return id

def Generate_Formatted_Recipes(recipeList, ingredientList):
  formattedRecipeList = recipeList.copy()
  recipeDictionary = {}
  for recipe in formattedRecipeList:
    recipe["calories"] = recipe["total_cal"]
    for index, ingredient in enumerate(recipe["ingredients"]):
      recipe["ingredients"][index] = Find_Ingredient_Id(ingredient["name"], ingredientList)
    recipeDictionary[recipe["id"]]=recipe
  return recipeDictionary

"""## Formatting IngredienList"""

global ingredientList
ingredientList = []
ingredientList = Normalized_Key(clonedIngredients, "cost", 100)
ingredientList = Normalized_Key(ingredientList, "cal", 100)
ingredientList = Generate_Id(ingredientList)
ingredientList = Format_Ingrediet_List_To_Dictionary(ingredientList)

print(ingredientList)

"""## Formatting Recipes"""

global recipesList

recipesList = []
recipesList = Sample(True, 500, clonedRecipes)
recipesList = Normalized_Key(recipesList, "total_cal", 100)
recipesList = Normalized_Key(recipesList, "total_cost", 100)
recipesList = Generate_Formatted_Recipes(recipesList, ingredientList)

"""##Generate Purchaseable List"""

global purchaseableList

purchaseableList = Generate_Purchaseable_List(ingredientList, None,3)
print(purchaseableList)

"""# States Calculation

##Generate Purchasing List
This function generate the missing ingredients as a List of ingredient object and how much the ingredient the Agent neds to buy
"""

def Generate_Purchased_Item(recipe, basket):
  purchaseList = {}
  for ingredient in recipe["ingredients"]:
    if ingredient not in basket:
      ingredientObject = ingredientList[ingredient]
      purchaseList[ingredient] = purchaseableList[ingredient]
  return purchaseList

"""## Calculate Cost
This function calculate the cost function for the recipe
"""

def Calculate_Cost(recipe, caloriesPreference, costPreference, purchaseList):
  cost = sum([ingredientList[ingredient]["cost"]*purchaseableList[ingredient] for ingredient in purchaseList])
  calories = sum([ingredientList[ingredient]["calories"] for ingredient in recipe["ingredients"]])
  return caloriesPreference*calories + costPreference*cost

"""##Generate Basket
This function should generate the left over ingredient after the recipe has been cooked and the neccessary items has been purchased
"""

def Generate_Basket(recipe, basket, purchasedList):
  clonedBasket = basket.copy()
  for purchasedItem in purchasedList:
    if purchasedItem not in clonedBasket:
      clonedBasket[purchasedItem] =  purchasedList[purchasedItem]
    else:
      clonedBasket[purchaseditem] = clonedBasket[purchaseditem] + purchasedList[purchasedItem]
  for ingredient in recipe["ingredients"]:
    if ingredient in clonedBasket:
      clonedBasket[ingredient] = clonedBasket[ingredient] - 1
      if clonedBasket[ingredient] <= 0:
        clonedBasket.pop(ingredient)
  return clonedBasket

"""## Calculate Heuristic Cost
We decided to remove the No-Repeated Food rules and the Batch Buy rule in order to generate an amissable heuristic to the node
"""

def Unrestrainded_Generate_Purchased_Item(recipe, basket):
  purchaseList = {}
  for ingredient in recipe["ingredients"]:
    if ingredient not in basket:
      purchaseList[ingredient] = 1
  return purchaseList

def Find_Cheapest_Recipe_With_Ingredient(ingredient, basket, caloriesPreference, costPreference, cookedMeal):
  min = None
  cheapestRecipe = None
  cheapestPurchaseList = None
  for recipe in recipesList:
    if ingredient in recipesList[recipe]["ingredients"] and recipesList[recipe]["id"] not in cookedMeal:
      purchaseList = Unrestrainded_Generate_Purchased_Item(recipesList[recipe], basket)
      cost = Calculate_Cost(recipesList[recipe], caloriesPreference, costPreference, purchaseList)
      if min == None or cost < min:
        min = cost
        cheapestRecipe = recipe
        cheapestPurchaseList = purchaseList
  if min == None:
    return (None, None, None)
  return (min, cheapestRecipe, cheapestPurchaseList)

def Calculate_Recipe_Cost(recipe, caloriesPreference, costPreference):
  costList = []
  caloriesList = []
  for ingredient in recipe["ingredients"]:
    costList.append(ingredientList[ingredient]["cost"])
    caloriesList.append(ingredientList[ingredient]["calories"])
  return (costPreference*sum(costList))+(caloriesPreference*sum(caloriesList))

def Sequential_Cheapest_Recipe_Cost_For(caloriesPreference, costPreference, cookedMeal, mealLeft):
  result = []
  for recipe in recipesList:
    if recipesList[recipe]["id"] not in cookedMeal:
      result.append(Calculate_Recipe_Cost(recipesList[recipe], caloriesPreference, costPreference))
  result.sort(reverse=False)
  return sum(result[:mealLeft])
        

def Calculate_Heuristic(basket,caloriesPreference,costPreference, mealNumber, numberOfMeal, cookedMeal):
  clonedBasket = basket.copy()
  heuristic = 0
  counter = mealNumber + 1
  while True:
    if len(clonedBasket) == 0:
      break
    counter += 1
    if counter > numberOfMeal:
      return None
    ingredient = list(clonedBasket.items())[0][0]
    costRecipeTuple = Find_Cheapest_Recipe_With_Ingredient(ingredient, clonedBasket, caloriesPreference, costPreference, cookedMeal)
    if costRecipeTuple[0] == None:
      return None
    clonedBasket = Generate_Basket(recipesList[costRecipeTuple[1]], clonedBasket, costRecipeTuple[2])
    heuristic += costRecipeTuple[0]
  mealLeft = numberOfMeal - counter
  if mealLeft != 0:
    heuristic += Sequential_Cheapest_Recipe_Cost_For(caloriesPreference, costPreference, cookedMeal, mealLeft)
  return heuristic



"""# Generating Successor Node based on the Parent Node"""

def Is_Vistied_Already(visitedCombinations, cookedMeal):
  clonedVisitedCombinations = visitedCombinations.copy()
  if len(cookedMeal) in clonedVisitedCombinations:
    for combinations in clonedVisitedCombinations[len(cookedMeal)]:
      shouldAddToCombination = True
      for meal in cookedMeal:
        if meal in combinations:
          shouldAddToCombination = False
          break
      if shouldAddToCombination:
        clonedVisitedCombinations[len(cookedMeal)].append(cookedMeal)
        return clonedVisitedCombinations, False
      return clonedVisitedCombinations, True
  clonedVisitedCombinations[len(cookedMeal)] = [cookedMeal]
  return clonedVisitedCombinations, False

def extract_cost(node):
    try:
        return int(node['cost'])
    except KeyError:
        return 0

def Generate_Successor_Node(currentNode, agent):
  for_sort_nodes = []
  if currentNode["mealNumber"] < agent["numberOfMeal"]:
    for recipe in recipesList:
      if recipe not in currentNode["cookedMeal"]:
        cookedMeal =  currentNode["cookedMeal"] + [recipe]
        purchasedList = Generate_Purchased_Item(recipesList[recipe], currentNode["basket"])
        basket = Generate_Basket(recipesList[recipe], currentNode["basket"], purchasedList)
        cost = Calculate_Cost(recipesList[recipe], agent["caloriesPreference"], agent["costPreference"], purchasedList)
        heuristic = Calculate_Heuristic(basket, agent["caloriesPreference"], agent["costPreference"], currentNode["mealNumber"], agent["numberOfMeal"], cookedMeal)
        visitedCombinations, isVisitedCombination = Is_Vistied_Already(agent["visitedCombinations"], cookedMeal)
        agent["visitedCombinations"] = visitedCombinations
        if heuristic is not None:
          for_sort_nodes.append({ 
              "basket": basket,
              "cost": currentNode["previousGrocceryCost"] + cost + heuristic,
              "previousGrocceryCost": currentNode["previousGrocceryCost"] + cost,
              "cookedMeal": cookedMeal,
              "mealNumber": currentNode["mealNumber"] + 1,
          })
    agent["fringe"] = agent["fringe"] + for_sort_nodes
    agent["fringe"].sort(key = extract_cost, reverse = False)


  return agent

"""# Finding Meal Plan"""

def Find_Meal_Plan(initState, agent, goalState):
  currentNode = {
      "cost": 0,
      "basket": initState["basket"],
      "cookedMeal": [],
      "mealNumber": 0,
      "previousGrocceryCost": 0
  }
  agent = Generate_Successor_Node(currentNode, agent)
  while len(agent["fringe"]) > 0:
    lowestCostNode = agent["fringe"].pop(0)
    print(lowestCostNode)
    if lowestCostNode["basket"] == goalState["basket"] and lowestCostNode["mealNumber"] == goalState["numberOfMeal"]:
      return lowestCostNode
    agent = Generate_Successor_Node(lowestCostNode, agent)
  return None

"""# Running The Code"""

caloriesPreference =  0.2
costPreference =  0.8
numberOfMeal = 4
goalState = {
    "basket": {},
    "numberOfMeal": numberOfMeal,
}

agent = { 
    "caloriesPreference": caloriesPreference, 
    "costPreference": costPreference, 
    "numberOfMeal": numberOfMeal, 
    "fringe": [],
    "visitedCombinations": {},
    }

initState = {
    "basket": {44:2, 13:2}
}

solution = Find_Meal_Plan(initState, agent, goalState)
print(solution)

ingredientFrequency = {}
for recipe in recipesList:
  for ingredient in recipesList[recipe]["ingredients"]:
      if ingredient not in ingredientFrequency:
        ingredientFrequency[ingredient] = 0
      else:
        ingredientFrequency[ingredient] += 1

sort_orders = sorted(ingredientFrequency.items(), key=lambda x: x[1], reverse=True)
print(sort_orders)



ingredientFrequency = {}
for recipe in rawRecipes:
  for ingredient in recipe["ingredients"]:
    if ingredient["name"] not in ingredientFrequency:
      ingredientFrequency[ingredient["name"]] = 0
    else:
      ingredientFrequency[ingredient["name"]] += 1
print(ingredientFrequency)